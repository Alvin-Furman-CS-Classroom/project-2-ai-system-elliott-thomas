"""Unit tests for module_1: each public method tested independently."""
#Generated by Cursor Agent
# 1/29/2026

import unittest
from pathlib import Path

from src import module_1

# Paths to integration test data (relative to project root; run tests from project root)
CASE_INIT_PATH = Path("integration_tests/module_1/case_init.json")
RULES_PATH = Path("integration_tests/module_1/rules.json")


def _tiny_constraints():
    """Minimal game_constraints (same shape as rules['game_constraints']) for grounding tests."""
    return {
        "suspects": ["Alice"],
        "rooms": ["Study"],
        "weapons": ["Candlestick"],
        "time_points": ["9pm"],
    }


# --- read_case_init ---


class TestReadCaseInit(unittest.TestCase):
    """Tests for module_1.read_case_init (loads case_init.json)."""

    def test_returns_dict_with_initial_evidence_and_metadata(self):
        """read_case_init(path) should return a dict with keys 'initial_evidence' and 'metadata'."""
        # We are testing that the return value has the expected top-level keys and types.
        result = module_1.read_case_init(CASE_INIT_PATH)
        self.assertIn("initial_evidence", result)
        self.assertIn("metadata", result)
        self.assertIsInstance(result["initial_evidence"], dict)
        self.assertIsInstance(result["metadata"], dict)

    def test_initial_evidence_maps_propositions_to_bool(self):
        """initial_evidence should map proposition names (str) to True or False."""
        # We are testing that every entry in initial_evidence is a string key and a boolean value.
        result = module_1.read_case_init(CASE_INIT_PATH)
        for key, val in result["initial_evidence"].items():
            self.assertIsInstance(key, str)
            self.assertIn(val, (True, False))

    def test_nonexistent_path_raises(self):
        """read_case_init should raise FileNotFoundError when the file does not exist."""
        # We are testing that a missing file path results in FileNotFoundError, not a silent failure.
        with self.assertRaises(FileNotFoundError):
            module_1.read_case_init("nonexistent_case_init.json")


# --- read_rules ---


class TestReadRules(unittest.TestCase):
    """Tests for module_1.read_rules (loads rules.json)."""

    def test_returns_dict_with_rules_and_game_constraints(self):
        """read_rules(path) should return a dict with 'rules', 'game_constraints', and 'metadata'."""
        # We are testing that the return value has the expected top-level keys and that rules is a list, game_constraints a dict.
        result = module_1.read_rules(RULES_PATH)
        self.assertIn("rules", result)
        self.assertIn("game_constraints", result)
        self.assertIn("metadata", result)
        self.assertIsInstance(result["rules"], list)
        self.assertIsInstance(result["game_constraints"], dict)

    def test_each_rule_has_id_if_then(self):
        """Each entry in rules should have keys 'id', 'if', and 'then'."""
        # We are testing that every rule object has the required keys for inference (id, if, then).
        result = module_1.read_rules(RULES_PATH)
        for rule in result["rules"]:
            self.assertIn("id", rule)
            self.assertIn("if", rule)
            self.assertIn("then", rule)

    def test_nonexistent_path_raises(self):
        """read_rules should raise FileNotFoundError when the file does not exist."""
        # We are testing that a missing rules file results in FileNotFoundError.
        with self.assertRaises(FileNotFoundError):
            module_1.read_rules("nonexistent_rules.json")


# --- ground_rule ---


class TestGroundRule(unittest.TestCase):
    """Tests for module_1.ground_rule (one rule template -> list of concrete rules)."""

    def test_returns_list(self):
        """ground_rule(rule, game_constraints) should return a list (of concrete rules)."""
        # We are testing that ground_rule returns a list (one entry per substitution of placeholders).
        rule = {"id": "R1", "if": ["At_PERSON_ROOM_TIME"], "then": "At_PERSON_ROOM_TIME"}
        out = module_1.ground_rule(rule, _tiny_constraints())
        self.assertIsInstance(out, list)

    def test_each_element_has_if_and_then(self):
        """Each grounded rule in the list should have 'if' and 'then' keys (no placeholders)."""
        # We are testing that each grounded rule has if/then and that placeholders (PERSON, ROOM, TIME) were replaced with concrete values.
        rule = {"id": "R1", "if": ["At_PERSON_ROOM_TIME"], "then": "At_PERSON_ROOM_TIME"}
        out = module_1.ground_rule(rule, _tiny_constraints())
        for g in out:
            self.assertIn("if", g)
            self.assertIn("then", g)
            for prop in g["if"]:
                self.assertTrue(
                    "PERSON" not in prop or "Alice" in prop,
                    f"placeholder PERSON not replaced in {prop}",
                )
                self.assertTrue(
                    "ROOM" not in prop or "Study" in prop,
                    f"placeholder ROOM not replaced in {prop}",
                )
                self.assertTrue(
                    "TIME" not in prop or "9pm" in prop,
                    f"placeholder TIME not replaced in {prop}",
                )


# --- ground_all_rules ---


class TestGroundAllRules(unittest.TestCase):
    """Tests for module_1.ground_all_rules (calls ground_rule for each rule)."""

    def test_returns_list(self):
        """ground_all_rules(rules, game_constraints) should return a list."""
        # We are testing that ground_all_rules returns a single list (all grounded rules concatenated).
        rules = [{"id": "R1", "if": ["Alibi_PERSON_TIME"], "then": "NOT_Culprit_PERSON_TIME"}]
        out = module_1.ground_all_rules(rules, _tiny_constraints())
        self.assertIsInstance(out, list)

    def test_collects_from_all_rules(self):
        """The returned list should be the concatenation of grounding each rule (length >= 0)."""
        # We are testing that the result has at least as many items as grounding one rule (length >= 0).
        rules = [{"id": "R1", "if": ["Alibi_PERSON_TIME"], "then": "X"}]
        out = module_1.ground_all_rules(rules, _tiny_constraints())
        self.assertGreaterEqual(len(out), 0)


# --- build_kb ---


class TestBuildKb(unittest.TestCase):
    """Tests for module_1.build_kb (initial_evidence -> KB dict)."""

    def test_returns_dict(self):
        """build_kb(initial_evidence) should return a dict."""
        # We are testing that build_kb returns a dict (the knowledge base).
        out = module_1.build_kb({"At_Alice_Study_9pm": True})
        self.assertIsInstance(out, dict)

    def test_contains_initial_evidence_entries(self):
        """The returned KB should contain every key-value pair from initial_evidence."""
        # We are testing that the KB is initialized with all propositions from initial_evidence (same keys and values).
        evidence = {"At_Alice_Study_9pm": True, "Weapon_Candlestick_Study": False}
        kb = module_1.build_kb(evidence)
        self.assertIs(kb.get("At_Alice_Study_9pm"), True)
        self.assertIs(kb.get("Weapon_Candlestick_Study"), False)


# --- rule_premises_met ---


class TestRulePremisesMet(unittest.TestCase):
    """Tests for module_1.rule_premises_met (grounded_rule['if'] all true in kb?)."""

    def test_true_when_all_premises_in_kb_as_true(self):
        """rule_premises_met should return True when every 'if' proposition is in kb with value True."""
        # We are testing that the function returns True when all premises of the rule are already in the KB as True.
        grounded = {"if": ["At_Alice_Study_9pm", "Weapon_Candlestick_Study"], "then": "Suspect_Alice"}
        kb = {"At_Alice_Study_9pm": True, "Weapon_Candlestick_Study": True}
        self.assertIs(module_1.rule_premises_met(grounded, kb), True)

    def test_false_when_one_premise_missing_from_kb(self):
        """rule_premises_met should return False when any 'if' proposition is not in kb."""
        # We are testing that the function returns False when at least one premise is missing from the KB.
        grounded = {"if": ["At_Alice_Study_9pm", "Weapon_Candlestick_Study"], "then": "Suspect_Alice"}
        kb = {"At_Alice_Study_9pm": True}
        self.assertIs(module_1.rule_premises_met(grounded, kb), False)

    def test_false_when_premise_in_kb_but_false(self):
        """rule_premises_met should return False when a premise is in kb but value is False."""
        # We are testing that a premise must be True in the KB; False does not satisfy the rule.
        grounded = {"if": ["At_Alice_Study_9pm"], "then": "X"}
        kb = {"At_Alice_Study_9pm": False}
        self.assertIs(module_1.rule_premises_met(grounded, kb), False)


# --- apply_rule ---


class TestApplyRule(unittest.TestCase):
    """Tests for module_1.apply_rule (if premises met, add grounded_rule['then'] to kb)."""

    def test_adds_then_to_kb_when_premises_met(self):
        """When premises are met, apply_rule should add grounded_rule['then'] to kb and return True."""
        # We are testing that when all premises hold, the conclusion is added to the KB and the function returns True.
        grounded = {"if": ["At_Alice_Study_9pm"], "then": "HadAccess_Alice_Candlestick"}
        kb = {"At_Alice_Study_9pm": True}
        changed = module_1.apply_rule(grounded, kb)
        self.assertIs(changed, True)
        self.assertIs(kb.get("HadAccess_Alice_Candlestick"), True)

    def test_does_nothing_when_premises_not_met(self):
        """When premises are not met, apply_rule should not add anything and return False."""
        # We are testing that when a premise is missing, the KB is unchanged and the function returns False.
        grounded = {"if": ["At_Alice_Study_9pm"], "then": "HadAccess_Alice_Candlestick"}
        kb = {}
        changed = module_1.apply_rule(grounded, kb)
        self.assertIs(changed, False)
        self.assertNotIn("HadAccess_Alice_Candlestick", kb)

    def test_records_contradiction_when_then_is_contradiction(self):
        """When grounded_rule['then'] is 'CONTRADICTION', apply_rule should add it to kb and return True."""
        # We are testing that contradiction rules add CONTRADICTION to the KB and return True so inference can stop.
        grounded = {"if": ["Alibi_Alice_9pm", "Culprit_Alice_9pm"], "then": "CONTRADICTION"}
        kb = {"Alibi_Alice_9pm": True, "Culprit_Alice_9pm": True}
        changed = module_1.apply_rule(grounded, kb)
        self.assertIs(changed, True)
        self.assertIs(kb.get("CONTRADICTION"), True)


# --- infer ---


class TestInfer(unittest.TestCase):
    """Tests for module_1.infer (repeatedly apply grounded rules until fixpoint or CONTRADICTION)."""

    def test_modifies_kb_in_place(self):
        """infer(kb, grounded_rules) should modify kb in place (same dict reference)."""
        # We are testing that infer updates the given kb dict (no new dict returned).
        kb = {"At_Alice_Study_9pm": True}
        grounded = [{"if": ["At_Alice_Study_9pm"], "then": "HadAccess_Alice_Candlestick"}]
        module_1.infer(kb, grounded)
        self.assertIn("At_Alice_Study_9pm", kb)

    def test_with_empty_rules_leaves_kb_unchanged(self):
        """With an empty grounded_rules list, kb should be unchanged except for initial contents."""
        # We are testing that with no rules to apply, the KB is left exactly as it was.
        kb = {"At_Alice_Study_9pm": True}
        module_1.infer(kb, [])
        self.assertEqual(kb, {"At_Alice_Study_9pm": True})


# --- has_contradiction ---


class TestHasContradiction(unittest.TestCase):
    """Tests for module_1.has_contradiction (is 'CONTRADICTION' in kb?)."""

    def test_true_when_contradiction_in_kb(self):
        """has_contradiction(kb) should return True when 'CONTRADICTION' is in kb (as key)."""
        # We are testing that the function returns True when the KB contains a CONTRADICTION (e.g. from a contradiction rule).
        kb = {"At_Alice_Study_9pm": True, "CONTRADICTION": True}
        self.assertIs(module_1.has_contradiction(kb), True)

    def test_false_when_no_contradiction_in_kb(self):
        """has_contradiction(kb) should return False when CONTRADICTION is not in kb."""
        # We are testing that the function returns False when no contradiction has been inferred.
        kb = {"At_Alice_Study_9pm": True}
        self.assertIs(module_1.has_contradiction(kb), False)


# --- run ---


class TestRun(unittest.TestCase):
    """Tests for module_1.run (entry point: read_case_init + read_rules + future inference/output)."""

    def test_accepts_paths_and_does_not_raise(self):
        """run(case_init_path, rules_path) should not raise when given valid integration test paths."""
        # We are testing that run completes without error when given valid Path objects to the integration test files.
        module_1.run(CASE_INIT_PATH, RULES_PATH)

    def test_accepts_string_paths(self):
        """run should accept str paths as well as Path objects."""
        # We are testing that run accepts string paths in addition to pathlib Path objects.
        module_1.run(str(CASE_INIT_PATH), str(RULES_PATH))


if __name__ == "__main__":
    unittest.main()
